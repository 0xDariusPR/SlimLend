// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {console} from "forge-std/Test.sol";

contract SlimLend is ERC20("LPSlimShares", "LPS") {

    uint256 totalDepositedTokens;
    uint256 totalBorrowedTokens; 
    uint256 lpSharePrice = 1e18;
    uint256 borrowerSharePrice = 1e18;
    uint256 lastUpdateTime = block.timestamp;
    IERC20 collateralToken;
    
    uint256 constant LTV = 1.5e18;
    uint256 constant OPTIMAL_UTILIZATION = 0.95e18;

    struct BorrowerInfo {
        uint256 borrowerShares;
        uint256 collateralTokenAmount;
    }

    mapping(address => BorrowerInfo) public borrowerInfo;

    // returns utilization [0-1] with 18 decimals
    function utilization() public view returns (uint256) {
        uint256 slot;
        assembly {
           slot := totalDepositedTokens.slot  
        }
        console.log(slot);
        return 10**18 * totalBorrowedTokens / totalDepositedTokens;
    }

    function interestRate(uint256 _utilization) public view returns (uint256 borrowerRate, uint256 lenderRate) {
        
    }

    function _updateSharePrices() internal {
        uint256 timeElapsed = block.timestamp - lastUpdateTime;
        if (timeElapsed > 0) {
            (uint256 borrowerRate, uint256 lenderRate) = interestRate(utilization());
            lpSharePrice = lpSharePrice * lenderRate * timeElapsed;
            borrowerSharePrice = borrowerSharePrice * borrowerRate * timeElapsed;
        }
        lastUpdateTime = block.timestamp;
    }

    function lpDepositAsset(uint256 amount, uint256 minSharesOut) public {
        _updateSharePrices();
        uint256 shares = 10**18 * amount / lpSharePrice;
        require(shares >= minSharesOut, "slippage");
        _mint(msg.sender, shares);
        totalDepositedTokens += amount;
    }

    function lpRedeemShares(uint256 amountShares, uint256 minAmountAssetOut) public {
        _updateSharePrices();
        uint256 amountAsset = amountShares * lpSharePrice / 10**18;
        require(amountAsset >= minAmountAssetOut, "slippage");
        _burn(msg.sender, amountShares);
        require(totalDepositedTokens - totalBorrowedTokens >= amountAsset, "insufficient liquidity");
        totalDepositedTokens -= amountAsset; 
    }

    function borrowerDepositCollateral(uint256 amount) public {
        borrowerInfo[msg.sender].collateralTokenAmount += amount;
    }

    function borrowerWithdrawCollateral(uint256 amount) public {

    }

    function borrowerWithdrawAsset(uint256 amount) public {
        _updateSharePrices();
        require(totalDepositedTokens - totalBorrowedTokens >= amount, "insufficient liquidity");
        uint256 _borrowerShares = 10**18 * amount / borrowerShares;
        borrowerInfo[msg.sender].borrowerShares += _borrowerShares;
        require(ltv(msg.sender) >= LTV, "insufficient LTV");
        totalBorrowedTokens += amount;
    }

    function ltv(address) public view returns (uint256) {
        return 1.5e18;
    }

    function borrowerRepayAsset(uint256 amountAsset) public {
        _updateSharePrices();
        
    }

    function liquidate(address borrower) public {

    }
}
